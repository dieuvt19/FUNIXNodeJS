'use strict';

/**
 * Module dependecies.
 */

const debug = require('debug')('pud:application');
const router = require('./router');
const Socket = require('./socket');
const context = require('./context');
const compose = require('koa-compose');
const Emitter = require('events');
const assert = require('assert');
const uws = require('uws');
const nanoid = require('nanoid');
const flatten = require('flatten');

// middlewares
const parse = require('./middleware/parse');
const batching = require('./middleware/batching');
const jsonrpc = require('./middleware/jsonrpc');

/**
 * Expose `Application` class.
 * Inherits from `Emitter.prototype`.
 */

module.exports = class Application extends Emitter {
  /**
   * Initialize a new `Application`.
   *
   * @api public
   */

  constructor() {
    super();

    this.settings = {
      newid: nanoid, // tiny id
      standard: true // respond standard jsonrpc
    };

    this.nsps = {}; // todo...
    this.middleware = [];
    this.methods = {}; // for not-found-error, no better solution
    this.clients = {};

    this.env = process.env.NODE_ENV || 'development';
    this.context = Object.create(context);

    debug('booting in %s mode', this.env);

    // load default middlewares, need lazyrouter???
    this.use(parse);
    this.use(batching);
    this.use(jsonrpc);
  }

  /**
   * Assign `setting` to `val`, or return `setting`'s value.
   *
   *    app.set('foo', 'bar');
   *    app.get('foo');
   *    // => "bar"
   *
   * Mounted servers inherit their parent server's settings.
   *
   * @param {String} setting
   * @param {*} [val]
   * @return {Server} for chaining
   * @public
   */

  set(setting, val) {
    if (arguments.length === 1) {
      // app.get(setting)
      return this.settings[setting];
    }

    debug('set "%s" to %o', setting, val);

    // set value
    this.settings[setting] = val;

    return this;
  }

  /**
   * Return `setting`'s value.
   *
   * @param {String} setting
   * @public
   */

  get(setting) {
    return this.set(setting);
  }

  /**
   * Use the given middleware `fn`.
   *
   *    app.use(fn)
   *    app.use(name, fn, ...)
   *    app.use([fn, fn, fn, ...])
   *    app.use([name, fn, fn, ...])
   *
   * @return {Application} self
   * @api public
   */

  use(fn) {
    let offset = 0;
    let name;

    // disambiguate app.use([fn])
    if (typeof fn !== 'function') {
      let arg = fn;
      while (Array.isArray(arg) && arg.length !== 0) {
        arg = arg[0];
      }

      if (typeof arg !== 'function') {
        offset = 1;
        name = fn;
      }
    }

    let fns = flatten(Array.prototype.slice.call(arguments, offset));
    if (fns.length === 0) {
      throw new TypeError('app.use() requires middleware functions');
    }

    for (let fn of fns) {
      if (typeof fn !== 'function') {
        throw new TypeError(`app.use() requires middleware function but got a ${typeof fn}`);
      }

      if (name) {
        fn = router(name, fn);
        this.methods[name] = true;
      }

      // add the middleware
      debug('use %s', fn._name || fn.name || '-');
      this.middleware.push(fn);
    }

    return this;
  }

  /**
   * Return a connection handler callback
   * for uwebsocket(uws) server.
   *
   * @return {Function}
   * @api public
   */

  callback() {
    if (!this.listeners('error').length) this.on('error', this.onerror);
    const fn = compose(this.middleware);

    return websocket => {
      const id = this.get('newid')();
      const socket = new Socket(id, this, websocket);
      this.clients[socket.id] = socket;

      socket.on('data', msg => {
        const ctx = this.createContext(socket, msg);
        const onerror = err => ctx.onerror(err);
        const onrespond = () => ctx.respond();
        return fn(ctx).then(onrespond).catch(onerror);
      });

      socket.once('close', () => {
        delete this.clients[id];
      });
    };
  }

  /**
   * Create an uws server and listening on the `port`.
   *
   *    app.listen(80)
   *    app.listen({host: '127.0.0.1', port: 80})
   *
   * @param {Number|Object} port
   * @return {Application} self
   * @api public
   */

  listen(port) {
    let opts = { host: 'localhost', port: Number(port) ? Number(port) : 0 };
    if (typeof port === 'object') opts = Object.assign(opts, port);

    // create uws server
    this.server = new uws.Server(opts, () => this.emit('listening'));
    this.server.on('connection', this.callback());
    this.server.on('error', error => this.emit('error', error));

    return this;
  }

  /**
   * Initialize a new context.
   *
   * @api private
   */

  createContext(socket, msg) {
    const context = Object.create(this.context);
    context.app = this;
    context.msg = msg;
    context.socket = socket;
    context.state = {};

    return context;
  }

  /**
   * Default error handler.
   *
   * @param {Error} err
   * @api private
   */

  onerror(err) {
    assert(err instanceof Error, `non-error thrown: ${err}`);

    if (-32601 === err.code || err.expose) return;
    if ('test' === this.env || this.silent) return;

    const msg = err.stack || err.toString();
    console.error();
    console.error(msg.replace(/^/gm, '  '));
    console.error();
  }
};
