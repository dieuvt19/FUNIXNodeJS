// forked from https://github.com/socketio/engine.io/blob/master/lib/transports/websocket.js

'use strict';

const debug = require('debug')('pud:websocket');
const Emitter = require('events');

module.exports = class Socket extends Emitter {
  constructor(id, app, socket) {
    super();

    this.id = id;
    this.readyState = 'opening';
    this.app = app;
    this.socket = socket;
    this.socket.on('message', this.onData.bind(this));
    this.socket.on('error', this.onError.bind(this));
    this.socket.once('close', this.onClose.bind(this));
  }

  /**
   * Called upon websocket message.
   *
   * @param {Any} data
   * @api private
   */

  onData(data) {
    debug('received "%s"', data);
    this.emit('data', data);
  }

  /**
   * Send data to client.
   *
   * @param {Array} packets
   * @api private
   */

  send(data) {
    debug('writing "%s"', data);
    const self = this;

    let opts = {}; // todo???

    function onEnd(err) {
      if (err) return self.onError('write error', err.stack);
    }

    self.socket.send(data, opts, onEnd);
  }

  /**
   * Send json to client.
   *
   * @param {Array} packets
   * @api private
   */

  json(obj) {
    if (typeof obj !== 'object') return this.send(obj);
    if (this.app.get('standard')) obj = Object.assign({ jsonrpc: '2.0' }, obj);

    this.send(JSON.stringify(obj));
  }

  /**
   * Emit notification  to client.
   *
   * @param {Array} packets
   * @api private
   */

  emit(name, params) {
    if (['open', 'data', 'connect', 'disconnect', 'error', 'close'].indexOf(name) !== -1) {
      Emitter.prototype.emit.apply(this, arguments);
    } else {
      this.json({ notification: name, params: params || [] });
    }
  }

  /**
   * Called upon websocket error.
   *
   * @param {Error} error object
   * @api private
   */

  onError(msg, desc) {
    if (this.listeners('error').length) {
      const err = new Error(msg);
      err.type = 'SocketError';
      err.description = desc;
      this.emit('error', err);
    } else {
      debug('ignored socket error %s (%s)', msg, desc);
    }
  }

  /**
   * Close the socket
   *
   * @param {Function} fn callback
   * @api public
   */

  close(fn) {
    if ('closed' === this.readyState || 'closing' === this.readyState) return;

    this.readyState = 'closing';
    this.socket.close();
    fn && fn();
  }

  /**
   * Called upon websocket close.
   *
   * @param {Error} error object
   * @api private
   */

  onClose() {
    this.readyState = 'closed';
    this.emit('close');
  }
};
